
CREATE TABLE Pago(
nroPago NUMBER(8) PRIMARY KEY,
nroFactura NUMBER (10) NOT NULL REFERENCES Factura(idF),
fechaPago DATE NOT NULL,
valor NUMBER(13) NOT NULL
);


1.
CREATE OR REPLACE PROCEDURE puntoUno(FECHAIN DATE)
AS 
IDFACTURA NUMBER;
FECHAFACTURA DATE;
VALOR_ENVIOFACTURA NUMBER;
METODO_PAGOFACTURA VARCHAR2(10);
CLIENTEFACTURA NUMBER;
NRO_TRAJETAFACTURA NUMBER;
VALORFACTURA NUMBER;
VALORP NUMBER;

BEGIN
	SELECT IDF, FECHA, VALOR_ENVIO, METODO_PAGO, CLIENTE, NRO_TARJETA, VALOR, VALORPAGADO INTO IDFACTURA, FECHAFACTURA, VALOR_ENVIOFACTURA, METODO_PAGOFACTURA, CLIENTEFACTURA, NRO_TRAJETAFACTURA, VALORFACTURA, VALORP
	FROM PAGO INNER JOIN FACTURA ON(IDF = NROFACTURA)
	WHERE VALORPAGADO != VALOR AND FECHAPAGO <= FECHAIN AND ROWNUM <= 1;

	DBMS_OUTPUT.PUT_LINE('IDF' || ' ' || 'FECHA' || ' ' || 'VALOR_ENVIO' || ' ' || 'METODO_PAGO' || ' ' || 'CLIENTE' || ' ' || 'NRO_TARJETA' || ' ' || 'VALOR FACTURA' || ' ' || 'VALOR_PAGADO');
  

	FOR I IN (SELECT IDF, FECHA, VALOR_ENVIO, METODO_PAGO, CLIENTE, NRO_TARJETA, VALOR, VALORPAGADO FROM PAGO INNER JOIN FACTURA ON(IDF = NROFACTURA) WHERE VALORPAGADO != VALOR AND FECHAPAGO <= FECHAIN)
	LOOP
		IDFACTURA := I.IDF;
		FECHAFACTURA := I.FECHA;
		VALOR_ENVIOFACTURA := I.VALOR_ENVIO;
		METODO_PAGOFACTURA := I.METODO_PAGO;
		CLIENTEFACTURA := I.CLIENTE;
		NRO_TRAJETAFACTURA := I.NRO_TARJETA;
		VALORFACTURA := I.VALOR;
		VALORP := I.VALORPAGADO;
   
   		DBMS_OUTPUT.PUT_LINE(IDFACTURA || ' ' || FECHAFACTURA || ' ' || VALOR_ENVIOFACTURA || ' ' || METODO_PAGOFACTURA || ' ' ||CLIENTEFACTURA || ' ' || NRO_TRAJETAFACTURA || ' ' || VALORFACTURA || ' ' || VALORP );
	END LOOP;

EXCEPTION
WHEN NO_DATA_FOUND THEN
 DBMS_OUTPUT.PUT_LINE('ERROR: NO SE HAN ENCONTRADO FACTURAS PARA LA FECHA SELECCIONADA');
END;
/

Prueba:
exec puntoUno('25/05/20');

2.
CREATE OR REPLACE PROCEDURE PUNTODOS(MES NUMBER, ANIO NUMBER) AS
CODIGOTE NUMBER;
NOMBRECITO VARCHAR2(20);
PRECIOMELO NUMBER;
RANKSITO NUMBER;
BEGIN
	SELECT CODIGO, NOMBRE, PRECIO, RANK() OVER (ORDER BY SUM(CANNTIDAD) DESC ) RANKING  INTO CODIGOTE,NOMBRECITO, PRECIOMELO,RANKSITO
	FROM FACTURA INNER JOIN COMPRA ON(IDF = NRO_FACTURA) INNER JOIN PRODUCTO ON (COMPRA.PRODUCTO =    PRODUCTO.CODIGO)
	WHERE EXTRACT(MONTH FROM FECHA) = MES AND EXTRACT(YEAR FROM FECHA) = ANIO  AND ROWNUM <=1
	GROUP BY CODIGO,NOMBRE, PRECIO;
	DBMS_OUTPUT.PUT_LINE('MAS VENDIDOS');
	DBMS_OUTPUT.PUT_LINE('------------');
	FOR I IN(SELECT CODIGO, NOMBRE, PRECIO, RANK() OVER (ORDER BY SUM(CANNTIDAD) DESC ) RANKING  INTO CODIGOTE,NOMBRECITO, PRECIOMELO,RANKSITO FROM FACTURA INNER JOIN COMPRA ON(IDF = NRO_FACTURA) INNER JOIN PRODUCTO ON (COMPRA.PRODUCTO =    PRODUCTO.CODIGO) WHERE EXTRACT(MONTH FROM FECHA) = MES AND EXTRACT(YEAR FROM FECHA) = ANIO  AND ROWNUM <=3 GROUP BY CODIGO,NOMBRE, PRECIO)
  	LOOP 
		NOMBRECITO := I.NOMBRE;
		DBMS_OUTPUT.PUT_LINE(NOMBRECITO);  
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('MENOS VENDIDOS');
	DBMS_OUTPUT.PUT_LINE('------------');
	FOR I IN(SELECT CODIGO, NOMBRE, PRECIO, RANK() OVER (ORDER BY SUM(CANNTIDAD)) RANKING  INTO CODIGOTE,NOMBRECITO, PRECIOMELO,RANKSITO FROM FACTURA INNER JOIN COMPRA ON(IDF = NRO_FACTURA) INNER JOIN PRODUCTO ON (COMPRA.PRODUCTO =    PRODUCTO.CODIGO) WHERE EXTRACT(MONTH FROM FECHA) = MES AND EXTRACT(YEAR FROM FECHA) = ANIO  AND ROWNUM <=3 GROUP BY CODIGO,NOMBRE, PRECIO)
	LOOP 
		NOMBRECITO := I.NOMBRE;
		DBMS_OUTPUT.PUT_LINE(NOMBRECITO);  
	END LOOP;

EXCEPTION
WHEN NO_DATA_FOUND THEN
	DBMS_OUTPUT.PUT_LINE('ERROR: NO SE ENCONTRARON DATOS PARA ESTA FECHA');
END;
/

3.

4.

5.
CREATE OR REPLACE TRIGGER trDevol
BEFORE INSERT ON DEVOLUCIONES FOR EACH ROW
DECLARE
FECHA DATE;
TODAY DATE := SYSDATE;
BEGIN
    SELECT VIGENCIA INTO FECHA FROM PRODUCTO WHERE PRODUCTO.CODIGO = :NEW.COD_PRODUCTO;
    IF TODAY > FECHA THEN
        RAISE_APPLICATION_ERROR(-20000,'GARANTIA VENCIDA');
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20500,'No existe el producto');
END;

Prueba:
INSERT INTO devoluciones VALUES (7,7,7,1107532048); prueba para producto inexistente
INSERT INTO devoluciones VALUES (1,5,5,8888814145); prueba para garantÃ­a vencida

6.
#CUANDO SE PROVEE EL INVENTARIO

CREATE OR REPLACE TRIGGER ActInventario
AFTER INSERT ON PROVEER FOR EACH ROW
DECLARE
	X NUMBER(10);
BEGIN
	SELECT CANTIDAD INTO X FROM PRODUCTO WHERE CODIGO = :NEW.IDPD;
	UPDATE PRODUCTO SET CANTIDAD = X + :NEW.QUANTITY WHERE PRODUCTO.CODIGO = :NEW.IDPD;
	
END;
/

#CUANDO HAY UNA COMPRA

CREATE OR REPLACE TRIGGER ActInventario2
BEFORE INSERT ON COMPRA FOR EACH ROW
DECLARE
	Y NUMBER(10);
	INSUF_INVENT EXCEPTION;
	PRAGMA EXCEPTION_INIT (INSUF_INVENT, -1438);
BEGIN
	SELECT CANTIDAD INTO Y FROM PRODUCTO WHERE CODIGO = :NEW.PRODUCTO;
	IF Y - :NEW.CANNTIDAD >= 0 THEN
		UPDATE PRODUCTO SET CANTIDAD = Y - :NEW.CANNTIDAD WHERE PRODUCTO.CODIGO = :NEW.PRODUCTO;
	ELSE
		RAISE INSUF_INVENT;
	END IF;

EXCEPTION
WHEN INSUF_INVENT THEN
	raise_application_error(-1438,'No hay productos suficientes');
	dbms_output.put_line('Error: No hay productos suficientes en el inventario');
END;
/

CREATE OR REPLACE PROCEDURE AUX (V1 NUMBER, V2 NUMBER, V3 NUMBER, V4 NUMBER) AS
BEGIN
	SAVEPOINT FLAG;
	INSERT INTO COMPRA VALUES(V1, V2, V3, V4);
	COMMIT;

EXCEPTION
WHEN OTHERS THEN
	ROLLBACK TO FLAG;
END;
/


Prueba:
INSERT INTO proveer VALUES(7,1,'23/05/20',1, 9000, 1 ); prueba para actualizar inventario despues de pedir al proveedor
EXEC AUX(8, 1, 1, 12); prueba para actualizar invenario despues de hacer una compra

7.


SELECT CODIGO_PRODUCTO #
  SELECT NOMBRE INTO NOMBRE_PRODUCTO FROM PRODUCTO WHERE CODIGO = CODIGO_PRODUCTO;
  SELECT IDPROVEEDOR INTO ID_PROVEEDOR FROM PROVEER WHERE IDPRODUCTO = CODIGO_PRODUCTO;
  SELECT NOMBRE, DIRECCION, CORREO INTO NOMBRE_PROVEEDOR, DIRECCION_PROVEEDOR, CORREO_PROVEEDOR FROM PROVEEDOR WHERE ID = ID_PROVEEDOR;



